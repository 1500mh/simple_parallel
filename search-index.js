var searchIndex = {};
searchIndex['simple_parallel'] = {"items":[[0,"","simple_parallel","Straight-forward functions and types for basic data parallel\noperations.",null,null],[5,"for_","","Execute `f` on each element of `iter`, in their own `scoped`\nthread.",null,{"inputs":[{"name":"i"},{"name":"f"}],"output":null}],[5,"both","","Execute `f` on both `x` and `y`, in parallel, returning the\nresult.",null,null],[0,"pool","","",null,null],[3,"Pool","simple_parallel::pool","A thread pool.",null,null],[3,"JobHandle","","A token representing a job submitted to the thread pool.",null,null],[3,"UnorderedParMap","","A parallel-mapping iterator, that yields elements in the order\nthey are computed, not the order from which they are yielded by\nthe underlying iterator. Constructed by calling\n`Pool::unordered_map`.",null,null],[3,"ParMap","","A parallel-mapping iterator, that yields elements in the order\nthey are yielded by the underlying iterator. Constructed by\ncalling `Pool::map`.",null,null],[11,"wait","","Block until the job is finished.",0,{"inputs":[{"name":"jobhandle"}],"output":null}],[11,"drop","","",0,{"inputs":[{"name":"jobhandle"}],"output":null}],[11,"drop","","",1,{"inputs":[{"name":"pool"}],"output":null}],[11,"new","","Create a new thread pool with `n_threads` worker threads.",1,{"inputs":[{"name":"pool"},{"name":"usize"}],"output":{"name":"pool"}}],[11,"for_","","Execute `f` on each element of `iter`.",1,{"inputs":[{"name":"pool"},{"name":"iter"},{"name":"f"}],"output":null}],[11,"unordered_map","","Execute `f` on each element in `iter` in parallel across the\npool's threads, with unspecified yield order.",1,{"inputs":[{"name":"pool"},{"name":"scope"},{"name":"i"},{"name":"f"}],"output":{"name":"unorderedparmap"}}],[11,"map","","Execute `f` on `iter` in parallel across the pool's threads,\nreturning an iterator that yields the results in the order of\nthe elements of `iter` to which they correspond.",1,{"inputs":[{"name":"pool"},{"name":"scope"},{"name":"i"},{"name":"f"}],"output":{"name":"parmap"}}],[11,"execute","","Run a job on the thread pool.",1,{"inputs":[{"name":"pool"},{"name":"scope"},{"name":"a"},{"name":"genfn"},{"name":"mainfn"}],"output":{"name":"jobhandle"}}],[11,"next","","",2,{"inputs":[{"name":"unorderedparmap"}],"output":{"name":"option"}}],[11,"next","","",3,{"inputs":[{"name":"parmap"}],"output":{"name":"option"}}],[0,"one_to_one","simple_parallel","",null,null],[3,"UnorderedParMap","simple_parallel::one_to_one","A parallel-mapping iterator that doesn't care about the order in\nwhich elements come out. Constructed by calling `unordered_map`.",null,null],[3,"ParMap","","A parallel-mapping iterator. Constructed by calling `map`.",null,null],[5,"unordered_map","","Execute `f` on each element in `iter`, with unspecified yield order.",null,{"inputs":[{"name":"scope"},{"name":"i"},{"name":"f"}],"output":{"name":"unorderedparmap"}}],[5,"map","","Execute `f` on `iter`, yielding the results in the order the\ncorrespond to in `iter`.",null,{"inputs":[{"name":"scope"},{"name":"i"},{"name":"f"}],"output":{"name":"parmap"}}],[11,"next","","",4,{"inputs":[{"name":"unorderedparmap"}],"output":{"name":"option"}}],[11,"next","","",5,{"inputs":[{"name":"parmap"}],"output":{"name":"option"}}]],"paths":[[3,"JobHandle"],[3,"Pool"],[3,"UnorderedParMap"],[3,"ParMap"],[3,"UnorderedParMap"],[3,"ParMap"]]};
searchIndex['crossbeam'] = {"items":[[0,"","crossbeam","Support for concurrent and parallel programming.",null,null],[3,"Scope","","",null,null],[3,"ScopedJoinHandle","","",null,null],[5,"scope","","",null,{"inputs":[{"name":"f"}],"output":{"name":"r"}}],[5,"spawn_unsafe","","Like `std::thread::spawn`, but without the closure bounds.",null,{"inputs":[{"name":"f"}],"output":{"name":"joinhandle"}}],[0,"mem","","Memory management for concurrent data structures",null,null],[3,"CachePadded","crossbeam::mem","Pad `T` to the length of a cacheline.",null,null],[0,"epoch","","Epoch-based memory management",null,null],[3,"Owned","crossbeam::mem::epoch","Like `Box<T>`: an owned, heap-allocated data value of type `T`.",null,null],[3,"Shared","","Like `&'a T`: a shared reference valid for lifetime `'a`.",null,null],[3,"Atomic","","Like `std::sync::atomic::AtomicPtr`.",null,null],[3,"Guard","","An RAII-style guard for pinning the current epoch.",null,null],[5,"pin","","Pin the current epoch.",null,{"inputs":[],"output":{"name":"guard"}}],[11,"new","","Move `t` to a new heap allocation.",0,{"inputs":[{"name":"owned"},{"name":"t"}],"output":{"name":"owned"}}],[11,"deref","","",0,{"inputs":[{"name":"owned"}],"output":{"name":"t"}}],[11,"deref_mut","","",0,{"inputs":[{"name":"owned"}],"output":{"name":"t"}}],[11,"eq","","",1,{"inputs":[{"name":"shared"},{"name":"shared"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"shared"},{"name":"shared"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"shared"}],"output":{"name":"shared"}}],[11,"deref","","",1,{"inputs":[{"name":"shared"}],"output":{"name":"t"}}],[11,"null","","Create a new, null atomic pointer.",2,{"inputs":[{"name":"atomic"}],"output":{"name":"atomic"}}],[11,"load","","Do an atomic load with the given memory ordering.",2,{"inputs":[{"name":"atomic"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"option"}}],[11,"store","","Do an atomic store with the given memory ordering.",2,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"ordering"}],"output":null}],[11,"store_and_ref","","Do an atomic store with the given memory ordering, immediately yielding\na shared reference to the pointer that was stored.",2,{"inputs":[{"name":"atomic"},{"name":"owned"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"shared"}}],[11,"store_shared","","Do an atomic store of a `Shared` pointer with the given memory ordering.",2,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"ordering"}],"output":null}],[11,"cas","","Do a compare-and-set from a `Shared` to an `Owned` pointer with the\ngiven memory ordering.",2,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"option"},{"name":"ordering"}],"output":{"name":"result"}}],[11,"cas_and_ref","","Do a compare-and-set from a `Shared` to an `Owned` pointer with the\ngiven memory ordering, immediatley acquiring a new `Shared` reference to\nthe previously-owned pointer if successful.",2,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"owned"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"result"}}],[11,"cas_shared","","Do a compare-and-set from a `Shared` to another `Shared` pointer with\nthe given memory ordering.",2,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"option"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"swap","","Do an atomic swap with an `Owned` pointer with the given memory ordering.",2,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"option"}}],[11,"swap_shared","","Do an atomic swap with a `Shared` pointer with the given memory ordering.",2,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"option"}}],[11,"unlinked","","Assert that the value is no longer reachable from a lock-free data\nstructure and should be collected when sufficient epochs have passed.",3,{"inputs":[{"name":"guard"},{"name":"shared"}],"output":null}],[11,"migrate_garbage","","Move the thread-local garbage into the global set of garbage.",3,{"inputs":[{"name":"guard"}],"output":null}],[11,"drop","","",3,{"inputs":[{"name":"guard"}],"output":null}],[11,"zeroed","crossbeam::mem","A const fn equivalent to mem::zeroed().",4,{"inputs":[{"name":"cachepadded"}],"output":{"name":"cachepadded"}}],[11,"new","","Wrap `t` with cacheline padding.",4,{"inputs":[{"name":"cachepadded"},{"name":"t"}],"output":{"name":"cachepadded"}}],[11,"deref","","",4,{"inputs":[{"name":"cachepadded"}],"output":{"name":"t"}}],[11,"deref_mut","","",4,{"inputs":[{"name":"cachepadded"}],"output":{"name":"t"}}],[8,"ZerosValid","","Types for which mem::zeroed() is safe.",null,null],[0,"sync","crossbeam","Synchronization primitives.",null,null],[3,"MsQueue","crossbeam::sync","A Michael-Scott lock-free queue.",null,null],[3,"AtomicOption","","",null,null],[3,"TreiberStack","","Treiber's lock-free stack.",null,null],[3,"SegQueue","","A Michael-Scott queue that allocates \"segments\" (arrays of nodes)\nfor efficiency.",null,null],[11,"new","","",5,{"inputs":[{"name":"atomicoption"}],"output":{"name":"atomicoption"}}],[11,"swap_box","","",5,{"inputs":[{"name":"atomicoption"},{"name":"box"},{"name":"ordering"}],"output":{"name":"option"}}],[11,"swap","","",5,{"inputs":[{"name":"atomicoption"},{"name":"t"},{"name":"ordering"}],"output":{"name":"option"}}],[11,"take","","",5,{"inputs":[{"name":"atomicoption"},{"name":"ordering"}],"output":{"name":"option"}}],[11,"new","","Create a enw, emtpy queue.",6,{"inputs":[{"name":"msqueue"}],"output":{"name":"msqueue"}}],[11,"push","","Add `t` to the back of the queue.",6,{"inputs":[{"name":"msqueue"},{"name":"t"}],"output":null}],[11,"pop","","Attempt to dequeue from the front.",6,{"inputs":[{"name":"msqueue"}],"output":{"name":"option"}}],[11,"new","","Crate a new, empty stack.",7,{"inputs":[{"name":"treiberstack"}],"output":{"name":"treiberstack"}}],[11,"push","","Push `t` on top of the stack.",7,{"inputs":[{"name":"treiberstack"},{"name":"t"}],"output":null}],[11,"pop","","Attempt to pop the top element of the stack.",7,{"inputs":[{"name":"treiberstack"}],"output":{"name":"option"}}],[11,"new","","Create a enw, emtpy queue.",8,{"inputs":[{"name":"segqueue"}],"output":{"name":"segqueue"}}],[11,"push","","Add `t` to the back of the queue.",8,{"inputs":[{"name":"segqueue"},{"name":"t"}],"output":null}],[11,"pop","","Attempt to dequeue from the front.",8,{"inputs":[{"name":"segqueue"}],"output":{"name":"option"}}],[11,"defer","crossbeam","",9,{"inputs":[{"name":"scope"},{"name":"f"}],"output":null}],[11,"spawn","","",9,{"inputs":[{"name":"scope"},{"name":"f"}],"output":{"name":"scopedjoinhandle"}}],[11,"join","","",10,{"inputs":[{"name":"scopedjoinhandle"}],"output":{"name":"t"}}],[11,"thread","","",10,{"inputs":[{"name":"scopedjoinhandle"}],"output":{"name":"thread"}}],[11,"drop","","",9,{"inputs":[{"name":"scope"}],"output":null}]],"paths":[[3,"Owned"],[3,"Shared"],[3,"Atomic"],[3,"Guard"],[3,"CachePadded"],[3,"AtomicOption"],[3,"MsQueue"],[3,"TreiberStack"],[3,"SegQueue"],[3,"Scope"],[3,"ScopedJoinHandle"]]};
initSearch(searchIndex);
